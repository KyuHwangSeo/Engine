

필담으로 해도 괜찮아 어차피 내용이 깊어서

천천히 생각해 봐요


일단, RTTI를 쓴다는건 (Dynamic_cast)

+ 템플릿(제네릭)을 쓴다는 것은


기존의 코드를 바꾸지 않고 컴포넌트를 추가 가능하다.
	(추가 코드 작성이 가능하다. 상속을 통해서..)
.. 라는 의미인데


특정 컴포넌트를 키를 잡고 그것을 통해서 검색하도록 하면


	그 시점에서 제네릭을 잃어버리는 것임
	물론 키를 만들 때 Typeid를 쓰면 됨...
	그런데 이건 리플렉션과 코드 제네레이션이 걸쳐있음

	여기까지 기술을 썼다면, 과감히 D언어를 쓰는 것도 좋음
	#define을 이용해서 클
		

	예시는 언리얼4

	디파인을 하면서, 클래스를 정의하고 동시에 문자열을 만들던가하는 식


그런데 일단 지금 저건 괜찮아 키를 typeid로 만든다면 일단은 되니까


저건 16바이트 정렬인데

DX를 상정한다는건가?

DX가 기본적으로 사용되는거지? 오브젝트라면 ㅅ상당


시간은 괜찮나



실제로 유니티에도 꺼지지 않는 컴포넌트가 있음


그리고 저 enable속성은 entity에도 있어야됨
(GameObject)
	가장 현실적으로 많이 쓰이는건데..

유니티의 경우
	모노.. 말하는거지?
	그 상속계층 설계야말로 자신이 결정해야돼
	물론 모노는 C#을 사용하고
	유니티의 철학이 있는거라서 약간 다름
	우리는 C++로 만드니까..


훌륭하다 저게 뭔뜻이래 ㅋㅋ

is_base_of 이거
C#에서는 where : T 절이랑 비슷한데
11에 있는지는 몰랐네 더 뒤에 있는줄 알았음 17쯤


상관없음

그런데 RTTI랑 다형성이랑 잘 섞어 쓰면 좋을듯
	아무래도 RTTI는 dynamic_cast는
	비싸다고 하니까..

	이게 다른 곳이면 상관없음 전혀!!!
	core loop이 될 가능성이 있는
	render / update라서 문제를 이야기하는것

	이건 매 프레임 (또는 더 많이)돌거든

	단편화도 캐시 히트/미스도
	분기 예측도 다 연관되어 있음

	워낙 많이 도니까

다른 곳은 전혀 문제 없음
	어떤 기술을 써도 문제 없을 정도로
	요즘 컴터가 빠르다.
	코어도 많고..
	소위 말하는 80/20 법칙에 해당하는 것
	80/20 못들어봤나?

성능의 80%를 잡아먹는 코드는 전체의 20%이다.



퍼포먼스의 80%정도를 좌지우지하는 코드는
	전체 코드의 20%정도의 분량밖에 안된다.

성능개선을 생각한다고 전체를 다 쥐어짜는건 낭비
	core-loop만 잘 최적화하면 됨
	물론 시간이 남으면 다른것도...


지금 구조에서는 render / update 이게 제일 중요함.

	내가 GetComponent<> 를 제네릭으로
	RTTI로 한 이유는

	이 함수의 호출이 아주 드물게 일어나기 때문

만약, 매 루프마다 GameObject(Entity)에서 특정 Renderer등의 컴포넌트를
	매번 GetComponent()하는 구조라면 그게 잘못된 것임
	유니티에서도 한 번 받아놓고 ( Awake()쯤에) 쓴다.
	성능상 이유도 그렇고 GC (가비지컬렉팅)이 발생하지 않게 하기
	위해서 레퍼런스 카운트를 증가시켜놓고 쓴다.
		또는 오브젝트 풀을 사용하던가.
	요는...

	typeid를 써서 키를 잡고 언오더드 맵을 쓴건 정말 잘했음
	C++11을 사용한 것도 잘했고

	그게 문제라는게 아니고 일단 80/20 찾아보고
	구조를 짤 때 '이유'가 있어야 됨

	왠지 느릴 것 같다고 생각해서 개선하는것은 일단 힘 낭비라서
	프로그래머는 시간도 없고 정신력도 나눠써야 하니까..


근데 보니까..
	내꺼보다 빠른거 맞아? 테스트 해 봤나?
	
	아냐 시간 재 봐 서로 다른 컴포넌트 5개정도 놓고
		랜덤으로...! 아니면 다른 식으로 최적화가 될테니

	랜덤으로 컴포넌트를 정해서 GetComponent하도록 하고
	시간을 비교 해봐 100000번 정도

	실력 향상에 도움이 될 거야
		나도 잘 모르겠지만 해 놓은거 보니까 내꺼나 니꺼나
		어쩌면 내것이 빠를지도 모르겠는데..
		나는 간단히 RTTI를 썼는데 이게 내부적으로 그냥
		특정 타입을 테이블화한건데
			(포인터 참조를 2~5번 하면 될거고)

		너는 무려 자료구조!! 를 쓰잖아
			(메모리 액세스가 있을건데.. 모르겠다)
			pair?
		혹시 이게 더 느릴거라고는 생각안한거냐
	

	확실히 Add시는 내가 빠를 것 같은데..
		Get시는 키 비교니까.. 해시펑션? ㅇㅋ

	여튼 한번 재봐 무조건 실력향상된다.

Script Execution Order
	이야기 한 적 있지? 모르나

	유니티에서 각 게임오브젝트에 붙어있는 컴포넌트들의
	이벤트 함수 (Awake(), Update(), Render()간의 실행 우위 순서)

컴포넌트2가 먼저, 1이 나중이지?
	같은 컴포넌트별로 오브젝트별 호출순서는 일단 넘어가고..

질문이 모호해서 잘 모르겠어 정확히..

찾아본건데 저 이벤트 함수 호출 순서 외에
	유저가 만든 컴포넌트를 불러주는데 그게 defaulttime 전후로 불러줌
	그 타이밍이 어디 있었는데..
	
	그리고 정확히 모르는거 하나는
		오브젝트별로. 업데이트가 되는것은 맞아
		그런데 그렇게 간단하지 않은게

		Renderer같은건 몰아서 찍어야 하잖아?
		그래서 (이것도 유니티를 소스레벨 라이선스로 안봐서
		정확히는 모르고 네오위즈 때의 카더라지만) 아마도
		Renderer컴포넌트를 만났을 때, 실행했을 때
		특정 큐에 넣어놓고.. 그것을 처리하는 부분이 나중에 어딘가에
		(당연히) 있게 되는 구조임

그래서 실행순서 플로챠트 자체도 간단하지는 않잖아?
	저거 그런데 저게 개략도야
	실제로는 이 부분은.. 엄청 복잡할거야 Renderer...
	그게 DX9때는 Renderstate별로 몰아찍는 것이 관건이었는데
	지금은 DX11은 그럴 필요도 없는게 하나의 버텍스 버퍼에 넣어놓고
	렌더스테이트도 어느정도 일괄 처리가 돼서
	DP Call한번에 서로다른 렌더스테이트와 버텍스버퍼를 쏠 수 있거든
		이전과는 약간 다르고 (성능상-부하가 주어지는 부분이)

	사실 나는 DX11로 자체엔진을 만들어 게임 서비스를 한 경험은 없어서
	(이미 유니티와 언리얼이 지배적)
	지금 우리나라에서도 몇 없을거여 아마 펄어비스.. 지웅이..

	이번에 만들어볼테니 한번 보자고..

그래서 실행순서는
	저 그림을 보고 참고하면 대략 이쪽은 이렇게 되지 않을까?
	하는 통찰이 나오는게..

	일단 업데이트는 렌더보다 앞이지?
		이것처럼.

	물리는 게임로직보다 전에 처리하네? 이것도 고민 많이 하는건데
		유니티에서 나온게 답일듯.

	찾아보면 알겠지만 FixedUpdate나 LateUpdate가 있음
	카메라는 LateUpdate에서 하는 것이 맞을듯.
		이것도 선택의 문제인데 여튼 언리얼과 유니티는 많은
		시행 착오를 한 것이니 참고하면 좋을듯.

	어떻게 어둠의 경로에서 유니티 소스레벨 구해볼게..


자체적인 키 애니메이션 계층도말고
	내가 움직이고 싶은 것도 계층화했다는거지?
	ㅇㅇ
	그건..
	C#레벨의 소스가 공개되어 있어 (이제민이 말한 것)
	C++레벨의 소스는 몇억짜리인데 C#레벨은 일단은 있어
	Transform 그런데 그거 소스도 있을거야 C#은
	
	그리고 인스펙터의 디버그모드로 보면

	일반 모드는 Rotation의 경우 Local Space의 오일러인데
	Debug는 쿼터니언에 액세스 가능
	또한 피벗을 보면 / 그리고 기즈모 이동을 보면
	맥스에서 이야기하는 Parent 좌표계도 있고
		피벗을 쓰려면 또 뭔가 있어야 할 것 같고
		(일단 네 구조는 피벗이라는 개념이 없잖어)
	그런것으로 봐서 Transform도 간단하지 않다는거지

	그래서 네가 만든 그 병렬구조? 키애니랑 유저가 바꾼 트랜스폼이랑
	서로 다른 각자의 계층도를 가진다는거.. 나쁘지 않은 것 같은데

	나같으면. 하나의 계층도만 둘 것 같고...

	대신에 애니메이션(키 애니메이션) 정보를 덧씌우는 함수를 잘 만들것 같다.


유니티 엔진에서 애니를 잡을 일..
	많지. 실제로 Transform애니메이션은 크게 복잡하지 않기 때문에.
	보통 모델링 소프트웨어를 쓰는 경우는 캐릭터가 나오는 경우.
	Rigging이 복잡한 경우.
	하지만 문짝이나.. 트리거? 등의 간단한 이동/회전은 얼마든지 유니티/언리얼에서
	바로 잡는다. 이게 훨씬 더 이터레이션이 적기 때문 (개발 속도)
		자체엔진으로 가는거 모델링 소프트웨어에서 내보내고
		다시 임포트하고 하는게 다 부하임. (프로젝트 진행 상 맨먼스)

	그리고 서로 왔다갔다도 돼
	유니티에서 잡고 블렌더에서 보고 다시 유니티로.. 같은 것
	FBX레벨에서 다 통합됨..
	
	결국 유니티/언리얼이 나온 이유가 그런 프로그램간의 전환 부하를 줄이기 위한
	솔루션 (Solution)을 만들기 위한거지..

	당연하지.. 있고. 그게 자연스럽게 되는게 맥스나 블렌더
	유니티는 그정도는 아니고 그것보다는 어떤게 되냐면..


	-> 리플렉션!
	그렇기는 한데.. 그게 동적으로 되잖아.. 컴파일을 안해도.
	그리고 그 스크립트가 뭔지도 모르는데 저 시스템이 동작하잖아
	Animation 컴포넌트를 수정하지도 않았는데 나중에 추가한 내 스크립트의
	함수를 부른다는 것..

	저걸 C++에서 되도록 하려면 둘 중 하나를 써야 돼 (아니면 둘 다)
		코드 제네레이션 / 리플렉션(반영) - 언어 스펙에 아직없으므로 #define꼼수..
		됩니다. #define은 언어 문법을 안타니까 그거랑어떻게 했더라..
		여튼. 됩니다. C++만 씁니다. 리플렉션 없이 리플렉션이 되도록.
		그러니까 수동 리플렉션? 하지만 HotReload는 안됨
		그건 컴파일러를 내장하고 .dll을 조합해야 함.

	일단. 하나하나씩 되는거부터 해보자.


	저런 시스템 없으면 어떻게 되냐면
		if (애니메이션 프레임 수 == 79)
		뭐 이런식으로 하드코딩? 이 되어야 돼 저걸 변수로 빼고 스크립트로 뺀다한들
		아까 봤던 리플렉션만 하겠나
		내가 추가한 함수가 바로 동적으로 뜨는게 훨씬 우위에 있다...

	아직 선배들은 저기까지는 못갔음


좀 다른 이야기인데

	접근 한정자를 잘 써서 기능의 구분을 하는 것이 좋겠다.
	자식으로 전파하면서 업데이트를 내린다는 것은 외부로 나갈 일이 없을듯.

	처음부터 Protected등으로 제한을 걸어놓고 코딩하면
	자연스럽게 생각이 잘못 튀거나 비효율적인 구조가 나올 여지를 차단한다.

	안해놓은 것 같아서..


그런거 좋아
	지금 이야기한게 상당히 핵심인데
	보통 컴포넌트 구조를 이야기해주면 모든 것을 하나로 통일하려고 하거든
	이유가 있어야돼 지금 이유가 있고 그 이유대로 설계와 구현을 했으니 그게 맞아

미안 놓쳤다 다시한번

예전에는 그게 Renderer의 큰 존재 이유였음
	지금도 중요하긴 한데 여튼 DX11찾아봐요 좀 바뀌었음
	이제 더 이상 DP Call을 줄이기 위해서 몰아찍는게 이득이 아닐지도
	DX12로 가잖아? 모든게 다 커맨드 리스트고 큐로 바뀜
	사실 DX11로 그래
	DP Call을 할 때.. 외부에서 보기에는 바로 찍는? 것 같지만
		최소한 그래픽스 카드로 보낼 것 같지만
		물론 보내긴 하지만..
	중간에 뭣짓을 하는지 몰라. 드라이버단에서 몰아서 찍어보낼수도 있고
		이게 영천형이 이야기한 제조사 최적화

	또는 DX11후반이나 DX12에서는 대놓고 커맨드 리스트가 있잖아
		배리어도 있어
		렌터스테이트 설정 - 그리기 - ||배리어|| 렌더 스테이스 설정 - 그리기 그리기 그리기..
		이걸 멀티스레딩 처리로 하는게 DX12의 핵심.

	각 그리기들이.. 멀티쓰레딩으로 돌면 DX12에서
		그래픽 카드 입장에서는 뭐가 언제 들어온건지 모르잖아
		(당연히 동기화객체같은것을 쓸 리가 없으니)
		그래서 누가 언제 어떻게 내린 명령인지도 적어넣고, 그 사이를 막고...
		멀티쓰레딩은 CPU레벨이고
			CPU에서 멀티쓰레드로 리스트를 만들어서 GPU에 넣으면
			GPU에서 해석하기 위한거지
	
	물론, DX11에서도 이것을 하느냐, 우리 레벨에서는 안하지. 그런데 내부적으로는...
		(당연히 하지. NVIDIA카드가 라데온보다 빨라야하잖아? 그래서 엔비디아의
		천재들이 비디오카드 드라이버나 여타 단에서 최적화를 하겠지)

	DX12에서는? 우리가 해야됨

	최적화
		저번에 이야기했지만 예전에는 경쟁사의 카드가 안돌도록
		특정 게임에서 최적화하는 코드도 넣거나
		그런 만행을 저질렀다고 하는데.. 지금도 할거야 아마. 망했어..

여튼
	나쁘지 않고
	다만... 뭐 많이 없다.?
	리소스 강의 듣고 디퍼드 들어가면 재미난 구현들이 많거든
		그림자나
		포스트이펙트 시리즈나
		SSAO/SSS/PBR/IBL같은거 한방에 다 나와..
	그 중에서 구조가 중요한건
		디퍼드 하나인듯 싶다.
		나머지는 글쎄.. 그냥 쉐이더를 잘 만지면 나와.

	인터넷에 좋은 자료가 많으니 Deferred Rendering (Shading)은 선행학습을 하는 것도
	나쁘지 않을 듯. PBR은 그냥 이론만 미리 해 두고.. 괜히 1달을 잡아놓은게 아니거든
	생각보다 수학적인게 좀 있고 (그래도 안배운 내용은 없음)

	일단 포스트이펙트 한개라도 구현을 해봐 (Blur가 제일 어렵다 제일 먼저 나오는데)
		그러면 거기에 맞는 구조가 있을거야
		일단 렌더타겟에 그리고 그것을 조합한다는 아이디어(이게 디퍼드의 시작)
		
		지연된 렌더링. 방식은 네가 말한대로 다수의 렌더타겟에 출력을 하고
		그것을 조합한다.

	동적 큐브맵ㅇㅇ
		무지하게 비싸지.. IBL도 근본적인 원리는 같은데 찍는게 중요한게 아니고
		그것을 빛 으로 해석하는게 어려운거지 별 내용은 없음
		(구면조화함수나 레이트레이싱..)

	그래서 보통 동적인것은 많이 아끼고 유니티처럼 라이트프로브 같은것을 박아
		동적으로 할 것을 미리 구해두는거지. 그리고 그것을 보간..
		예전의 라이트맵이랑 근본적인 아이디어는 같음..
		그래서 베이킹한다고 하잖아. 미리 구워두는 것임. 미리 만들어두는 것

	그리고 리얼타임이랑 조합? 하지..
		지금 저건 빛도 없고 라이트프로브도 없어서 안만드는 거고
		저 구현은 유니티 특 이라서 엔진마다 달라
		하지만 생각하는건 비슷비슷하고..
		DX12의 레이트레이싱은 아직 안해봐서 몰라 (내가 모름)
		DX12만 된다고 하고 RTX라고 붙은것
		vnidia 2080 RTX 1기가 쓰고 있는 이 컴퓨터.. 비싸게 주고 산거다..
		지금 니들이 쓰는 2기용은 그래픽카드만 350만원.. / 200만원
		NVIDIA 3060 + 3090 3090은 교수들3개 여분 2개..

엔진은
	시작은 잘 했고
	실력을 키우는 목적이니 애착을 가지고 만들면 매우 좋고..
	가돗이나 스트라이더 보면 되게 크거든.. 헤메지 말고
	나도 어차피 3기도 4기도 그래픽 수업 해야돼서 매년 발전하니까
	이번에 잘 만들어보지 뭐..
		사실 PBR/PBL아직 완성 안됐어
		강의를 하려면 정말 다 알아야 되는데..
		저번에 봤던 그거 맞어 잠시 보여줫던거

	그런데 겐지가 블렌더만큼 나와야지 (정확히는 완전히 일치해야 함.)
		블렌더/언리얼/맥스 이렇게 3개를 자체엔진으로 정확히 따라할 수 있어야 함..


궁금한거 있나
	다시 놓쳤어
	애니메이션을.. 교체... 메쉬.
		IDLE -> WALK
		일단 애니메이션을 바꿨으면 뭔가 달라질 이유가 없는데?
		애니가 없는 노드들의 데이터를 리셋 안한거 아냐?

	애니메이션을 바꾼다는건 모든 노드를 리셋한다는 것 맞고
		블렌딩을 하지 않는 이상...
		그리고 그랬는데 뭔가 이상이 있다는건 잘못 짠거지.

		그런데 그 말을 들어보면.. 뭔가 잘못 짠것 같아.
		이전의 애니메이션 데이터가 남았다는 건데.. 남으면 안되는데?
		애니메이션 키 데이터가 길이가 다르거나 트랙이 더 있거나 하면 죽을것 같은데?
		이전게 남는다는게 일단 거림칙하고.. 아니라면 그냥 리셋하면 되지.

오후 12:21 2021-06-22

우리가 면담을 했던가?

조만간 면담 해요 그 이전에 
	한마디만 하면 인생에 때가 있는데
	어떤 때가 온 것 같아
	물 들어올 때 공부 열심히 해요
	
	그게 항상 되는게 아니더라고
	지금 (공부를 하고, 하고싶고, 되고.. ) 되는게 참 귀한 거니까..
	ㅇㅋ














		



















